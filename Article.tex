\documentclass{article}
\usepackage{graphicx}
\graphicspath{{C:\Users\Vanya\Desktop}}
\usepackage[indentfirst]{titlesec}
\usepackage{ucs} 
\usepackage[utf8x]{inputenc} % Включаем поддержку UTF8  
\usepackage[russian]{babel}
\usepackage{listings}
\usepackage{color}

\lstset{
  basicstyle={\small},
  breaklines=true,
  language={[Sharp]C},
  showstringspaces=false,
  tabsize=4,
  escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  keywordstyle=\color[rgb]{0,0,1},
  commentstyle=\color[rgb]{0.133,0.545,0.133},
  stringstyle=\color[rgb]{0.627,0.126,0.941}
}
\lstset{morekeywords={var}}

\begin{document}
\title{Roslyn}
\author{Потапов И.А.}
\date{}
\maketitle
\newpage

\section{Введение}
Знания, приведённые в данной статье, получены при разработке статического анализатора кода PVS-Studio, часть которого, отвечающая за проверку C#-проектов, написана с использованием Roslyn API.

Статью можно разделить на 2 больших логических раздела:
Общая информация про Roslyn. Обзор инструментов, предоставляемых им для разбора и анализа кода. Приводится как общее описание сущностей и интерфейсов, так и взгляд на них с точки зрения разработчика статического анализатора.
Особенности, которые следует учитывать при разработке статических анализаторов. О том, как использовать Roslyn для разработки продуктов этого класса, что нужно учитывать при разработке диагностических правил, как их писать, пример диагностики и т.п.


Если же разбить статью на разделы более детально, можно выделить следующие части:
\begin{itemize}
 \item Roslyn. Что это и зачем нам нужно?
 \item Подготовка к разбору проектов и анализу файлов.
 \item Синтаксическое дерево и семантическая модель как 2 основные компоненты, необходимые для статического анализа.
 \item Syntax Visualizer – расширение среды разработки Visual Studio, а также наш помощник в разборе кода.
 \item Особенности, которые необходимо принимать во внимание при разработке статического анализатора кода.
 \item Пример диагностического правила.
\end{itemize}

\section{Roslyn}
Roslyn – платформа с открытым исходным кодом, разрабатываемая корпорацией Microsoft, и содержащая в себе компиляторы и средства для разбора и анализа кода, написанного на языках программирования C# и Visual Basic.

Roslyn используется в среде разработки Microsoft Visual Studio 2015. Различные нововведения наподобие code fixes реализуются как раз за счёт использования Roslyn.

С помощью средств анализа, предоставляемыми платформой Roslyn, можно производить полный разбор кода, анализируя все поддерживаемые конструкции языка.

Среда Visual Studio позволяет создавать на основе Roslyn как встраиваемые в саму IDE инструменты (расширения Visual Studio), так и независимые приложения (standalone инструменты).

Исходный код Roslyn доступен в соответствующем репозитории на GitHub. Это позволяет посмотреть, что и как работает, а в случае обнаружения какой-либо ошибки – сообщить о ней разработчикам. 

Рассматриваемый ниже вариант создания статического анализатора и диагностических правил является не единственным. Возможно создание диагностик, основанное на использовании стандартного класса DiagnosticAnalyzer. Встроенные диагностики Roslyn используют именно это решение. Это позволит, например, произвести интеграцию со стандартным списком ошибок Visual Studio, предоставляет возможность подсветки ошибок в текстовом редакторе и т.д. Но стоит помнить, что если эти диагностики будут существовать внутри процесса devenv.exe, являющегося 32-битным, накладываются серьёзные ограничения на объём используемой памяти. В некоторых случаях это критично и не позволит провести глубокий анализ больших проектов (того же Roslyn). К тому же в этом случае Roslyn оставляет разработчику меньше контроля по обходу дерева и самостоятельно занимается распараллеливанием этого процесса. 

C# анализатор PVS-Studio является standalone-приложением, что решает проблему с ограничением на использование памяти. Помимо этого, мы получаем больший контроль над обходом дерева, реализуем распараллеливание необходимым нам образом, тем самым больше контролируя процесс разбора и анализа кода. Так как опыт в создании анализатора, работающего по такому принципу (PVS-Studio С++), уже есть, его было бы целесообразно использовать и при написании C# анализатора. Интеграция со средой разработки Visual Studio осуществляется аналогично C++ анализатору – посредством плагина, вызывающего это standalone-приложение. Таким образом, используя уже имеющиеся наработки, удалось создать анализатор для нового языка и связать его с уже имеющимися решениями, встроив в полноценный продукт – PVS-Studio.

\section{Особенности, которые необходимо учитывать при разработке статического анализатора}
Существует ряд правил, которых необходимо придерживаться, разрабатывая статические анализаторы. Соблюдение этих правил позволит сделать более качественный продукт и реализовывать функциональные диагностические правила.

\begin{enumerate} 
  \item Для глубокого и качественного анализа нужна полная информация о всех типах, встретившихся в коде. В большинстве диагностических правил недостаточно простого обхода узлов дерева, часто приходится обрабатывать типы выражений и получать информацию об анализируемых объектах. Для этого и нужна семантическая модель, которая должна быть корректной. Напомню, что для этого проект должен быть скомпилированным, все зависимости должны быть на месте. Тем не менее, даже если это так, не стоит пренебрегать различными проверками результатов, получаемых с использованием семантической модели;
  \item  Важно правильно выбирать тип узла для начала анализа. Это позволит уменьшить количество перемещений по дереву и различных приведений. Естественно, это также уменьшит объем кода, упростив его поддержку. Для того, чтобы лучше определиться со стартовым узлом анализа, используйте синтаксический визуализатор;
  \item  Если нет уверенности в том, что код является ошибочным, лучше не ругаться. Но в пределах разумного, конечно. Дело в том, что если анализатор будет ругаться по делу и без дела, появится слишком большое количество шума в виде ложных срабатываний, на фоне которых реальные ошибки найти будет трудно. С другой стороны, если совсем ни на что не ругаться, толку от анализатора тоже не будет. Поэтому иногда приходится выбирать компромисс, но конечная цель – свести количество ложных срабатываний к минимуму, в идеале – к 0;
  \item  При разработке диагностических правил важно предусмотреть все возможные, невозможные, а также ряд невероятных случаев, с которыми вы можете столкнуться в ходе анализа. Для этого необходимо разрабатывать большое количество юнит-тестов, как позитивных – фрагментов кода, где должна срабатывать ваша диагностика, так и негативных – тех фрагментов, на которые не стоит выдавать предупреждения;
  \item  В процесс разработки диагностических правил отлично вписывается методология TDD. Изначально разрабатываются наборы позитивных и негативных юнит-тестов, и лишь после этого начинается реализация диагностического правила. Это позволит легче ориентироваться с синтаксическим деревом по мере реализации, так как перед глазами уже будут примеры различных деревьев. К тому же на этом этапе пригодится синтаксический визуализатор;
  \item  Важно тестировать анализатор на реальных проектах. Как бы вы ни старались, скорее всего не удастся покрыть юнит-тестами все случаи, с которыми придётся столкнуться диагностическим правилам анализатора. Проверка же анализатора на реальных проектах позволит выявить места, где правила отрабатывают некорректно, следить за изменениями работы анализатора, увеличивать базу юнит-тестов.
\end{enumerate}

\section{Пример диагностического правила. Поиск пропущенного оператора throw}
В статическом анализаторе кода PVS-Studio есть диагностика V3006, которая ищет пропущенный оператор throw. Логика следующая – создаётся объект исключения, но при этом он никак не используется (ссылка на него никуда не передаётся, не возвращается из метода и т.п.). Тогда, скорее всего, можно сказать, что программист пропустил оператор throw. В итоге исключение не будет сгенерировано, а созданный объект просто будет уничтожен при следующей сборке мусора.

Так как с правилом мы уже определились, можно начинать писать юнит-тесты.

Пример позитивного теста:
\begin{lstlisting}
if (cond)
  new ArgumentOutOfRangeException();
\end{lstlisting}
Пример негативного теста:
\begin{lstlisting}
if (cond)
  throw new FieldAccessException();
\end{lstlisting}
Можно выделить следующие пункты в алгоритме работы диагностики:
\begin{enumerate}
\item Подписываемся на обход узлов типа ObjectCreationExpressionSyntax. Этот тип узлов соответствует созданию объекта с использованием оператора new – как раз то, что нам нужно;
\item Убеждаемся, что тип создаваемого объекта является совместимым с System.Exception (т.е. либо этим типом, либо производным). Если это так, будем считать, что тип является типом исключения. Для получения типа будем использовать семантическую модель (напоминаю, что модель предоставляет возможность получать тип выражения);
\item Проверяем, что объект не используется (ссылка на объект никуда не записывается и не передаётся);
\item Если предыдущие пункты соблюдены – выдаём предупреждение.
\end{enumerate}


Ниже будет приведена возможная реализация данного диагностического правила. Я специально несколько переписал и упростил код, чтобы сделать его короче и легче для понимания. Но даже такое небольшое правило справляется со своей задачей и находит реальные ошибки.

Общий код поиска пропущенного оператора throw:
\begin{lstlisting}
readonly String ExceptionTypeName = typeof(Exception).FullName;
Boolean IsMissingThrowOperator(SemanticModelAdapter model,        
                               ObjectCreationExpressionSyntax node)
{           
  if (!IsExceptionType(model, node))
    return false;

  if (IsReferenceUsed(model, node.Parent))
    return false;

  return true; 
}
\end{lstlisting}
Как видно из кода, здесь выполняются действия, описанные в алгоритме, приведённом выше. В первом условии выполняется проверка того, что тип создаваемого объекта – тип исключения. Вторая проверка используется для определения, используется ли созданный объект.

Кого-то может смутить тип SemanticModelAdapter. Ничего хитрого здесь нет, это обёртка над семантической моделью. В данном примере она используется для тех же целей, что и обыкновенная семантическая модель (объект типа SemanticModel).

Метод проверки, является ли тип исключением:
\begin{lstlisting}
Boolean IsExceptionType(SemanticModelAdapter model,
                        SyntaxNode node)
{
  ITypeSymbol nodeType = model.GetTypeInfo(node).Type;

  while (nodeType != null && !(Equals(nodeType.FullName(),
                                      ExceptionTypeName)))
    nodeType = nodeType.BaseType;

  return Equals(nodeType?.FullName(),
                ExceptionTypeName);

}
\end{lstlisting}
Логика проста – получаем информацию о типе, проверяем всю иерархию наследования. Если в итоге обнаруживается, что один из базовых типов – System.Exception, считаем, что тип создаваемого объекта – тип исключения.

Метод проверки, что ссылка никуда не передаётся и не сохраняется:
\begin{lstlisting}
Boolean IsReferenceUsed(SemanticModelAdapter model, 
                     SyntaxNode parentNode)
{
  if (parentNode.IsKind(SyntaxKind.ExpressionStatement))
    return false;

  if (parentNode is LambdaExpressionSyntax)
    return (model.GetSymbol(parentNode) as IMethodSymbol)
             ?.ReturnsVoid == false;

  return true;
} 
\end{lstlisting}
Можно было бы проверить, используется ли ссылка, но пришлось бы рассматривать слишком много случаев: возвращение из метода, передачу в метод, запись в переменную и т.п. Гораздо проще рассмотреть случаи, когда ссылка никуда не передаётся и не записывается. Это покрывается описанными выше проверками.

С первой, думаю, всё понятно – мы проверяем, что родительский узел – простое выражение. Вторая проверка тоже не таит в себе секретов. Если родительский узел – лямбда-выражение, проверим, что ссылка не возвращается из лямбды.

\section{Заключение}
Подводя итог, хотелось бы сказать, что Roslyn — это действительно мощная платформа, на основе которой можно создавать различные многофункциональные инструменты – анализаторы, инструменты рефакторинга и много чего ещё. Низкий поклон Microsoft за Roslyn, а также за возможность его свободного использования.

Однако наличия платформы мало – нужно знать, как с ней работать. Основные понятия и принципы работы и были описанные в данной статье. Полученные знания помогут вам легче и быстрее вникнуть в процесс разработки с использованием Roslyn API, было бы желание.
\newpage
\begin{thebibliography}{99}

\bibitem{} Введение в Roslyn. Использование для разработки инструментов статического анализа. / Хабр
\bibitem{} Введение в Microsoft “Roslyn” CTP / Хабр
\bibitem{} Roslyn / Wikipedia
\bibitem{} Компилятор Roslyn / ITVDN
\end{thebibliography}

\end{document}